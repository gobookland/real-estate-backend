let Sector,ApolloError;_a00‍.x([["sectors",()=>sectors],["addSector",()=>addSector],["deleteSector",()=>deleteSector]]);_a00‍.w("../../models/Sector",[["default",["Sector"],function(v){Sector=v}]]);_a00‍.w("apollo-server",[["ApolloError",["ApolloError"],function(v){ApolloError=v}]]);


// * Query
// List sectors depend on type(can be null)
       const sectors = async (_, { type, parent }) => {
	try {
		let sectors;
		if (type) sectors = await Sector.find({ type, parent });
		else sectors = await Sector.find({});
		return sectors;
	} catch (e) {
		_a00‍.g.console.log(e);
	}
};

// * Mutation
// Add sector with name, type
       const addSector = async (_, { type, parent, name }) => {
	try {
		const exist = await Sector.find({ type, parent, name });
		if (exist.length !== 0) {
			return new ApolloError('Duplicate Sector', 'duplicate_sector');
		}

		const sector = new Sector({
			type,
			parent,
			name,
		});

		await sector.save();

		return sector;
	} catch (e) {
		_a00‍.g.console.log(e);
	}
};

// Delete sector with name, type
       const deleteSector = async (_, { sectorInput }) => {
	try {
		let deletedSectors = [];
		for (let sector in sectorInput) {
			const deletedSector = await Sector.findOneAndDelete({ ...sector });
			deletedSectors.push(deletedSector);
			if (!sector.parent) {
				const deleted = await Sector.deleteMany({
					parent: sector.name,
					type: 'detail',
				});

				deletedSectors.push(delteed);
			}
		}
		return deletedSector;
	} catch (e) {
		_a00‍.g.console.log(e);
	}
};
